// Generated by AI. Original prompt: Write comprehensive system tests for Turn_Manager.cs
using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;
using System.Collections;
using PropertyTycoon;
using System.Reflection;

public class TurnManagerSystemTests
{
    private GameObject turnManagerObject;
    private GameObject propertyManagerObject;

    private Turn_Script turnManager;

    private PropertyManager pmanager;
    [UnitySetUp]
    public IEnumerator SetUp()
    {
        turnManagerObject = new GameObject();
        turnManager = turnManagerObject.AddComponent<Turn_Script>();
        
        propertyManagerObject = new GameObject();
        pmanager = propertyManagerObject.AddComponent<PropertyManager>();

        // Initialize players and dependencies
        turnManager.players = new boardPlayer[2];
        for (int i = 0; i < 2; i++)
        {
            GameObject playerObj = new GameObject();
            turnManager.players[i] = playerObj.AddComponent<boardPlayer>();
            turnManager.players[i].name="player "+i.ToString();
        }
        
        turnManager.Start();
        yield return null; // Allow Awake() to initialize
    }

    [TearDown]
    public void TearDown()
    {
        Object.DestroyImmediate(turnManagerObject);
        foreach (var player in turnManager.players) Object.DestroyImmediate(player.gameObject);
    }

    // System Test: Verify full turn cycle advances rounds
   [UnityTest]
    public IEnumerator Test_RoundIncrementsAfterFullCycle()
    {
        // Save original time scale and speed up time
        // this worked apparently???????
        float originalTimeScale = Time.timeScale;
        Time.timeScale = 100f; // Makes 0.5s delay ~0.005s
        
        turnManager.currentPlayerIndex = 1; // Last player in a 2-player game
        turnManager.turnEnded = true; // Enable ending the turn
        for (int i=0;i<2;i++){
        turnManager.EndTurnButtonClicked();
        yield return new WaitUntil(() => turnManager.currentPlayerIndex == 0); // Wait for index 
        }
        Time.timeScale = originalTimeScale; //fix timescale after
        Assert.AreEqual(2, turnManager.round); // Round should increment after all players
    }
    
    // System Test: Verify player movement updates TileCount
    [UnityTest]
    public IEnumerator Test_PlayerMovePhase_UpdatesTilePosition()
    {
        turnManager.pmanager=pmanager;
         // Save original time scale and speed up time
        // this worked apparently???????
        float originalTimeScale = Time.timeScale;
        Time.timeScale = 100f; // Makes 0.5s delay ~0.005s
        
        boardPlayer currentPlayer = turnManager.players[0];
        int initialTile = currentPlayer.TileCount;
        
        // Simulate dice roll
        turnManager.isWaitingForRoll = false;
        turnManager.StartCoroutine(turnManager.PlayerMovePhase(currentPlayer,true));
        yield return new WaitUntil(() => currentPlayer.TileCount > initialTile);
        Time.timeScale = originalTimeScale; //fix timescale after
        Assert.Greater(currentPlayer.TileCount, initialTile);
    }
    // TurnManagerSystemTests.cs
    [UnityTest]
    public IEnumerator Test_JailMechanics()
    {
        // Setup
        var jailedPlayer = turnManager.players[0];
        jailedPlayer.inJail = true;
        jailedPlayer.TileCount = 11;

        // Test 3 turns in jail
        for (int i = 0; i < 3; i++)
        {
            turnManager.StartCoroutine(turnManager.PlayerMovePhase(jailedPlayer, true));
            yield return new WaitForSeconds(0.1f);
            Assert.AreEqual(11, jailedPlayer.TileCount);
        }

        // Verify release after 3 turns
        turnManager.StartCoroutine(turnManager.PlayerMovePhase(jailedPlayer, true));
        yield return new WaitForSeconds(0.1f);
        Assert.IsFalse(jailedPlayer.inJail);
        Assert.AreNotEqual(11, jailedPlayer.TileCount);
    }

    [UnityTest]
    public IEnumerator Test_DoubleDiceMovement()
    {
        // Setup
        turnManager.testMode = false;
        var currentPlayer = turnManager.players[0];
        int initialTile = currentPlayer.TileCount;
        // Save original time scale and speed up time
        // this worked apparently???????
        float originalTimeScale = Time.timeScale;
        Time.timeScale = 100f; // Makes 0.5s delay ~0.005s


        // Execute roll
        turnManager.StartCoroutine(turnManager.PlayerMovePhase(currentPlayer));
        yield return new WaitUntil(() => currentPlayer.TileCount > initialTile);
        

        // Verify valid movement range
        int movedTiles = currentPlayer.TileCount - initialTile;
        Assert.IsTrue(movedTiles >= 2 && movedTiles <= 12);
        Time.timeScale = originalTimeScale; //fix timescale after

    }

    [Test]
    public void Test_RentSkipWhenOwnerJailed()
    {
        var owner = new boardPlayer { inJail = true };
        var payer = new boardPlayer { balance = 1000 };
        var property = new Property ("Test property",50,"brown", 10);

        payer.PayRent(100, property);
        Assert.AreEqual(1000, payer.balance);
    }

}




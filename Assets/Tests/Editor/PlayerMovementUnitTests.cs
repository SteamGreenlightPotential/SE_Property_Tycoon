// Generated by AI. Original prompt: Write comprehensive unit tests for Player_Movement.cs
using NUnit.Framework;
using UnityEngine;
using System.Collections;
using PropertyTycoon;
using System.Collections.Generic; 

public class PlayerMovementUnitTests
{
    private boardPlayer player;
    private GameObject testGameObject;

    [SetUp]
    public void SetUp()
    {
        testGameObject = new GameObject();
        player = testGameObject.AddComponent<boardPlayer>();
        player.OwnedProperties = new List<Property>();
    }

    [TearDown]
    public void TearDown()
    {
        Object.DestroyImmediate(testGameObject);
    }

    // Unit Test: Verify TileCount increments correctly during movement
    [Test]
    public void Test_NextDir_UpdatesTileCount()
    {
        player.TileCount = 0;
        Vector3 dir = player.NextDir(); // Requires internal access
        Assert.AreEqual(1, player.TileCount);
    }

    // Unit Test: Validate direction calculation for corner tiles
    [Test]
    public void Test_NextDir_ReturnsCorrectDirection()
    {
        player.TileCount = 9; // Edge of top-right corner
        Vector3 dir = player.NextDir();
        Assert.AreEqual(Vector3.down, dir);
    }

    // Unit Test: Successful tile purchase
    [Test]
    public void Test_BuyTile_SufficientBalance()
    {
        Property testProp = new Property("Test", 100, "Brown", 10);
        player.BuyTile(testProp);
        Assert.Contains(testProp, player.OwnedProperties);
    }

    // Unit Test: Failed tile purchase due to low balance
    [Test]
    public void Test_BuyTile_InsufficientBalance()
    {
        Property expensiveProp = new Property("Luxury", 9999, "DBlue", 50);
        player.BuyTile(expensiveProp);
        Assert.IsEmpty(player.OwnedProperties);
    }
}